import antDesignSystemImage from '../assets/images/ant-design-system.png';
import carbonDesignSystemImage from '../assets/images/carbon-design-system.png';
import materialDesignSystemImage from '../assets/images/material-design-system.png';
import themePreviewImage from '../assets/images/theme-preview.png';

import icons from '../system/icons.js';
import styles from '../system/styles.js';
import theme from '../system/theme.js';
import typography from '../system/typography.js';

# UI Systems and Complexity

This whitepaper explores complexity in building and maintaining [UI systems](#ui-systems).

The document opens with a reminder of the importance of modelling UI as a function of state, a concept that is widely understood and applied by most developers, while highlighting common negligence of such principles when managing styles and CSS.  A brief overview of design systems and a definition of UI systems is then naturally introduced.  While such systems serve as ways to manage complexity in UI development, the document presents an interactive story on how complexity becomes unavoidable irregardless of the ideal choices we make at every point of the way.  The document argues that it is not "good" abstractions nor updating specs that will guard us from growing complexity, but rather, an increased emphasis on applying [the Unix philosophy](#the-unix-philosophy) in building small, composable and interoperable programs, paired with tools and processes that improve our [system knowledge](#system-knowledge), that will provide us with an iterative approach to managing complexity in UI systems.  The document ends with an exposition on [the `uinix` philosophy](#the-uinix-philosophy) as a way to remediate complexity in UI systems, accompanied with relevant links to [demos](#uinix-systems) and [references](#references).

This document contains *interactive* [React][react] code examples.  Feel free to edit the code appropriately in the editor to preview changes!

## Table of Contents
```toc
exclude: Table of Contents
from-heading: 2
to-heading: 3
```

## view = f(s)

Modern declarative UI libraries (such as [React][react]) emphasize the important concept of:

> View as a function of state.

This powerful model allows us to reason about building UIs as no more than writing and composing functions, as demonstrated by the following examples.

### Simple functions

Here are some simple functions that we can compose:

```js live
() => {
  const greet = name => {
    return `Hello ${name}`;
  };

  const uppercase = x => {
    return x.toUpperCase();
  };

  const shout = pipe([greet, uppercase]);

  return shout('Jesse Pinkman');
}
```

Feel free to edit the code on the right (e.g. providing another value for `name`, or changing the operation of the composed `shout` method).

### View functions

View functions, more commonly known as *components*, are simply functions!

```js live
() => {
  const Button = ({ text }) => {
    return <button>{text}</button>;
  };

  const Big = ({ children }) => {
    return (
      <div style={{ transform: 'scale(3)', transformOrigin: 'top left' }}>
        {children}
      </div>
    );
  };

  const Red = ({ children }) => {
    return (
      <div style={{ backgroundColor: 'red', color: 'white' }}>
        {children}
      </div>
    );
  };

  const attachChildren = (x) => ({ children: x });

  const BigRedButton = ({ text }) => {
    return (
      <Big>
        <Red>
          <Button text={text} />
        </Red>
      </Big>
    );
    // can be composed as simple functions with a pipe!
    // return pipe([
    //   Button,
    //   attachChildren,
    //   Red,
    //   attachChildren,
    //   Big,
    // ])({ text });
  };

  return <BigRedButton text="Boom!" />;
}
```

## style = f(s)

### Styles/CSS: The unfairly unloved child of UI development

While the concept of function composition is well-understood by most people and is rigorously applied in all areas in the UI stack (components, APIs, state, utils, test),

> Somewhere, somehow, and everytime, styles/CSS are left as an afterthought at best, and layers of overriding and duplicated logic in codebases at worst.

If you disagree on this, it is a simple experiment to see if you can lay out the full visible specs and rules on styles and their interactions and effects on components.  If you are able to do this, you have solved and mastered a commonly overlooked aspect of UI development, but the further sections may still interest you.

For the rest of us, we will begin to fallback on the argument that *"our styles are closely organized with components and therefore it is not completely a bad situation"*, and continue to lie to ourselves that our abstractions guards us from fundamentally a lack of visibility and understanding on how inherited styles have their effects on components.  Perhaps, we have all been subconcsciously influenced to not consider the quest to modularize and compose styles because of the fundamental inheritance nature of C(ascading)S(tyle)S(heets).

### Back to basics

Let's keep an open mind and go back to basics with a simple proposition that we can reason about

> Style as a function of state.

Revisiting our simple functions,

```js live
() => {
  const greet = name => {
    return `Hello ${name}`;
  };

  const uppercase = x => {
    return x.toUpperCase();
  };

  const shout = pipe([greet, uppercase]);

  return shout('Jesse Pinkman');
}
```

### Style functions

Let's try to model styles as either style objects or *style functions* that return style objects.  With the help of an [`Element`][element-component] component, we will assign these style functions to the `styles` propand specify the data for these function in the `styleProps` prop.


```js live
() => {
  const styles = {
    button: { // a simple object
      borderRadius: '4px',
      border: '1px solid rgb(222, 225, 228)',
      paddingBottom: '4px',
      paddingLeft: '16px',
      paddingRight: '16px',
      paddingTop: '4px',
    },
    big: ({ isBig }) => { // a simple function
      return {
        fontSize: isBig ? '32px' : undefined,
        padding: isBig ? '32px 16px': undefined
      };
    },
    red: {
      backgroundColor: 'red',
      color: 'white',
    },
  };

  return (
    <Layout direction="column" spacing="l">
      <Element
        as="button"
        styles={styles.button}>
        Button
      </Element>
      <Element
        as="button"
        styleProps={{
          isBig: true,
        }}
        styles={styles.big}>
        Big
      </Element>
      <Element
        as="button"
        styles={styles.red}>
        Red
      </Element>
    </Layout>
  );
}
```

Last reminder that the code examples are interactive, so feel free to configure the `styleProps` accordingly!

Just as functions can be composed, we will compose styles by simply providing multiple smaller style functions to the `styles` prop.  For details on how style composition is implemented in the [`Element`][element-component] component, we recommend readers exploring [`uinix-ui`][uinix-ui] in more detail.

```js live
() => {
  const styles = {
    button: {
      borderRadius: '4px',
      border: '1px solid rgb(222, 225, 228)',
      paddingBottom: '4px',
      paddingLeft: '16px',
      paddingRight: '16px',
      paddingTop: '4px',
    },
    big: ({ isBig }) => {
      return {
        fontSize: isBig ? '32px' : undefined,
        padding: isBig ? '32px 16px': undefined
      };
    },
    red: {
      backgroundColor: 'red',
      color: 'white',
    },
  };

  return (
    <Layout direction="column" spacing="l">
      <Element
        as="button"
        styleProps={{
          isBig: true,
        }}
        styles={[
          styles.big,
          styles.red,
          styles.button,
        ]}>
        BigRedButton
      </Element>
    </Layout>
  );
}
```

By going back to basics, we discovered that we can easily compose and organize styles as simple functions!  While it will take us time to shake off old habits and build new muscles, it is exciting to look forward on treating style functions with the same respect as other UI functions!

ðŸ’ª

## ui = f(s)

With style functions formally joining the family of simple and composable functions, an example UI project might look like:

```sh
src
  utils/
    ...
    greet.js
    uppercase.js
    shout.js
  components/
    ...
    button.js
    big.js
    red.js
  styles/
    ...
    button.js
    big.js
    red.js
```

And we can continue to develop with the principle that

> UI as a function of state.

ðŸŽ‰

## Design Systems

The preceding sections describe the backbone on how to organize building blocks in code, but does not deal with the actual *decisions and choices* we make to determine what we should be building and maintaining.

A [design system][design-system] serves as a source of truth for design decisions.  Design system frameworks and patterns are largely acknowledged to help manage growing complexities of building applications.  The following provides a list of popular design systems:

- [Material Design System][material-design-system]
<img src={materialDesignSystemImage} width="100%" />
- [Carbon][carbon-design-system]
<img src={carbonDesignSystemImage} width="100%" />
- [Ant][ant-design-system]
<img src={antDesignSystemImage} width="100%" />

It is important to note that every design system is different, not simply visually, but philosophically.  These differences reflect the *decisions and choices* on how the system manages and organizes design specs and rules.

## UI Systems

### Definition

The definition for UI systems is not formally established in the community, but we will provide a simple definition:

> **UI System**: an implementation of a design system in code.

With this definition, the following UI systems implement their corresponding design systems:
- [`antd`][antd]: implements [Ant Design System][ant-design-system]
- [`carbon-components`][carbon-components]: implements [Carbon Design System][carbon-design-system]
- [`material-ui`][material-ui]: implements [Material Design System][material-design-system]

### UI System Libraries

It is also worthwhile to note that *UI system libraries* implement UI systems.  Examples of such libraries include:
- [`theme-ui`][theme-ui]
- [`uinix-ui`][uinix-ui]

## Entropy

As we further our discussions into systems, we will naturally talk about the entropy and complexity of systems.

Entropy is a measure of disorder.  In the natural world, the [second law of thermodynamics][second-law-of-thermodynamics] states that entropy can only remain unchanged or increase in a closed system.  [Software entropy][software-entropy] echoes this phenomenon in development of (closed) software systems.  Relating back to design and UI systems, we should expect entropy to ineviatbly build up as we make changes to systems.

## Complexity

[Complexity][complexity], while not the same as entropy, can be measured by the total independent ways components in a system can interact with each other.  A complex system is commonly mislabelled to be complicated.  The former concept deals with a certain and quantifiable way to measure a system, but the latter concept deals with *human perception and imperfect knowledge* of the system.

We often say to ourselves,

> "This code is too complicated, and we need to refactor it."

But less often do we pause and reflect that the complicated code maybe due to our lack of understanding of the current system. Rarely do we possess complete [system knowledge](#system-knowledge) and we should safely assume our knowledge and understanding of any system is imperfect at best.  In the best case scenarios, we make the right choices on limited knowledge and refactor code with meaningful abstractions.  In the worst case scenarios, we convince ourselves that our abstractions are well-formed, as we unknowingly increase system complexity and future complications.

Personally, I like to view complexity in the following way:

> "Complexity is unavoidable because we have to make choices, and imperfect knowledge of systems contribute to eventual complications experienced in the system."

## Elliot and the Complexity Beast

This section assumes the form of an interactive story, and follows the quest of a frontend developer, Elliot, as he works through building UI components with his Design team.  At every point of implementation, he tries his best at thoughtfully reducing and managing complexity, only to find that he can never escape complexity, but faces the eventual beast, one that has been shaped by the very choices made during the journey.

A quick reminder again that all code examples are *interactive*, so feel free to adjust the code as you follow Elliot on his journey!

### Hello Elliot

Elliot begins his journey with a simple [`Element`][element-component] rendering some text:

```js live
<Element>
  The quick brown fox jumps over the lazy dog
</Element>
```

He receives initial design requirements to style it accordingly:

```js live
<Element
  styles={{
    borderRadius: '4px',
    border: '1px solid rgb(222, 225, 228)',
    padding: '4px 16px',
  }}>
  The quick brown fox jumps over the lazy dog
</Element>
```

He then receives further requirements that this component should support conditional behaviors if it `isBig`.  He does so and implements it in a naturally simple way:

```js live
() => {
  return (
    <Element
      styleProps={{
        isBig: true,
      }}
      styles={({ isBig }) => ({
        borderRadius: '4px',
        border: '1px solid rgb(222, 225, 228)',
        fontSize: isBig ? '32px' : '14px',
        padding: isBig ? '16px 32px': '4px 16px',
      })}>
      The quick brown fox jumps over the lazy dog
    </Element>
  );
}
```

### `Danger`

A few days later, he receives another requirement to apply the red styles on this component:

```js live
() => {
  return (
    <Element
      styleProps={{
        isBig: true,
      }}
      styles={({ isBig }) => ({
        backgroundColor: 'red',
        borderRadius: '4px',
        border: '1px solid rgb(222, 225, 228)',
        color: 'white',
        fontSize: isBig ? '32px' : '14px',
        padding: isBig ? '16px 32px': '4px 16px',
      })}>
      The quick brown fox jumps over the lazy dog
    </Element>
  );
}
```

He ships his simple component, and gives it a name `Danger`.  Everyone, including himself, loves it and is proud of his work!

### `Warning`

A few days later, he receives design requirements on a new area of an application.  He's named the component `Warning` and here is the current implementation:

```js live
() => {
  return (
    <Element
      styles={{
        backgroundColor: '#ffe7ba',
        borderRadius: '6px',
        border: '1px solid rgb(222, 225, 228)',
        color: '#ff7a45',
        padding: '4px 16px',
      }}>
      The quick brown fox jumps over the lazy dog
    </Element>
  );
}
```

### `Notice`

He notices that `Danger` and `Warning` can share a common implementation and discusses it with his design team:

> **Elliot**: "Hey folks, it seems that the only differences between `Danger` and `Warning` are the  `borderRadius`, and that `Warning` does not require a `isBig` variant.  Can we confirm how we should reason about `Danger` and `Warning`?"
>
> **Design**: "The `borderRadius` should be the same, but `Warning` can never be big, ever."

Elliot goes back to the drawing board and thinks carefully how he would model this new requirement and avoid duplication and reduce complexity.  Luckily, this seems easy enough:

```js live
() => {
  const variants = {
    'danger': {
      backgroundColor: 'red',
      color: 'white'
    },
    'warning': {
      backgroundColor: '#ffe7ba',
      color: '#ff7a45',
    },
  };

  const styles = {
    notice: ({ isBig, variant }) => ({
      borderRadius: '6px',
      border: '1px solid rgb(222, 225, 228)',
      fontSize: isBig ? '32px' : '14px',
      padding: isBig ? '16px 32px': '4px 16px',
      ...variants[variant],
    }),
  };

  return (
    <Layout direction="column" spacing="l">
      <Element
        styleProps={{
          isBig: true,
          variant: 'danger',
        }}
        styles={styles.notice}>
        Danger
      </Element>
      <Element
        styleProps={{
          variant: 'warning',
        }}
        styles={styles.notice}>
        Warning
      </Element>
    </Layout>
  );
}
```

What Elliot has done is great so far:
- He was able to convince the Design team to reduce an unwanted degree of complexity by standardizing `borderRadius`.
- He was able to decouple and abstract styles as a function.
- The style function supports both needs of `Danger` and `Warning` appropriately.
- Both the Engineering and Design team can now reason about this code as a centralized component.

Elliot proudly names this component `Notice` and explains how its behavior to his team.  The Design team did a review and confirmed everything looks great and they loved the updates.

### `BigRedButton`

A few days later, Elliot receives requirements to create a `BigRedButton` component.  Implementing this to spec, he notices that it shares some aspects with the `Notice` component he created earlier.

```js live
() => {
  return (
    <Element
      as="button"
      styleProps={{
        isBig: true
      }}
      styles={({ isBig }) => ({
        backgroundColor: 'red',
        borderRadius: '6px',
        border: '1px solid rgb(222, 225, 228)',
        color: 'white',
        fontSize: isBig ? '32px' : '14px',
        padding: isBig ? '32px 48px': '4px 16px',
      })}>
      BigRedButton
    </Element>
  );
}
```

Being the diligent and responsible developer, Elliot goes back to the drawing board to see how he can decouple and organize this code into smaller parts:

```js live
() => {
  const dangerStyle = {
    backgroundColor: 'red',
    color: 'white',
  };

  const warningStyle = {
    backgroundColor: '#ffe7ba',
    color: '#ff7a45',
  }

  const bigStyle = ({ isBig }) => ({
    fontSize: isBig ? '32px' : '14px',
    padding: isBig ? '16px 32px': '4px 16px',
  });

  const variants = {
    danger: dangerStyle,
    warning: warningStyle,
  };

  const styles = {
    big: bigStyle,
    danger: dangerStyle,
    notice: ({ isBig, variant }) => ({
      borderRadius: '6px',
      border: '1px solid rgb(222, 225, 228)',
      ...variants[variant],
      ...bigStyle({ isBig }),
    }),
  };

  return (
    <Layout direction="column" spacing="l">
      <Element
        as="button"
        styleProps={{
          isBig: true
        }}
        styles={[
          styles.danger,
          styles.big,
        ]}>
        BigRedButton
      </Element>
      <Element
        styleProps={{
          variant: 'danger',
        }}
        styles={styles.notice}>
        Notice (Danger)
      </Element>
      <Element
        styleProps={{
          variant: 'warning',
        }}
        styles={styles.notice}>
        Notice (Warning)
      </Element>
    </Layout>
  );
}
```

Studying the style functions, he sees an opportunity to further refactor and organize this meaningfully, by breaking out the `big` and `danger` styles to aid composition, so that they can be reused in `BigRedButton` while leaving the exact same behaviors for `Notice`  He's following the exact recommendations that we've laid out in earlier sections on [`style = f(s)`](#style--fs)!

But little does he know, this innocent and well-intentioned choice, will be what awakens the sleeping Complexity Beast.

### `BigNotSoRedButton`

A few days later, the Design team comes back to Elliot and raises a non-negotiable change that <code><span style="color: red;">BigRedButton</span></code> is too red, and that <code><span style="color: #ff85c0;">BigNotRedButton</span></code>is what they had in mind to use.

Elliot, after days of successfully refactoring code, confidently heads to the drawing board again, and studies the relevant parts of his code:

```js live
() => {
  const dangerStyle = {
    backgroundColor: 'red',
    color: 'white',
  };

  const warningStyle = ({ isBig }) => ({
    fontSize: isBig ? '32px' : '14px',
    padding: isBig ? '16px 32px': '4px 16px',
  });

  const notSoRedStyle = {
    backgroundColor: '#ff85c0',
    color: 'white',
  };

  const bigStyle = ({ isBig }) => ({
    fontSize: isBig ? '32px' : '14px',
    padding: isBig ? '16px 32px': '4px 16px',
  });

  const styles = {
    big: bigStyle,
    danger: dangerStyle,
    notSoRed: notSoRedStyle,
  };

  return (
    <Layout direction="column" spacing="l">
      <Element
        as="button"
        styleProps={{
          isBig: true
        }}
        styles={[
          styles.notSoRed,
          styles.big,
        ]}>
        BigNotSoRedButton
      </Element>
    </Layout>
  );
}
```

He realizes that the simplest way to do this is to introduce a new `notSoRedStyle`, since replacing the red value in `dangerStyle` would break the requirements for the `Notice` component.

He is not very happy to add this new spec, but there doesn't seem to be any other better way to model this problem.  He double checks with the design team just to make sure:

> **Elliot**: "Hey folks, are we absolutely sure the `danger` color tone should differ across components?  It's <span style="color: red;">red</span> in `Notice.danger` but <span style="color: #ff85c0;">notSoRed</span> in `BigNotSoRedButton`.".
>
> **Design**: "Yeah we're sure, we've gotten feedback from users and let's go with what you have done here."

### Composition to the Rescue

Over the next few weeks, various additional requirements are placed on `Notice` and `BigNotSoRedButton`, and Elliot repeats the process of managing complexity by refactoring shareable code, only to find that he cannot avoid either:
1. Introducing new specs, or
2. Conditional-branching of applying shared logic

Note that the two points above are the inevitable factors of complexity.

It occurred to him that the current state of the "reusable" and abstracted code is actually *more complex* than the duplicated but more *composable* approach presented below:

```js live
() => {
  const styles = {
    big: {
      fontSize: '32px',
      padding: '16px 32px',
    },
    danger: {
      backgroundColor: 'red',
      color: 'white'
    },
    warning: {
      backgroundColor: '#ffe7ba',
      color: '#ff7a45',
    },
    notSoRed: {
      backgroundColor: '#ff85c0',
      color: 'white',
    },
    notice: {
      borderRadius: '6px',
      border: '1px solid rgb(222, 225, 228)',
      fontSize: '14px',
      padding: '4px 16px',
    },
  };

  return (
    <Layout direction="column" spacing="l">
      <Element
        styles={[
          styles.notice,
          styles.big,
          styles.danger,
        ]}>
        Notice (Danger)
      </Element>
      <Element
        styles={[
          styles.notice,
          styles.warning,
        ]}>
        Notice (Warning)
      </Element>
      <Element
        as="button"
        styles={[
          styles.notSoRed,
          styles.big,
        ]}>
        BigNotSoRedButton
      </Element>
    </Layout>
  );
}
```

A key thing to note here is that the conditional branching logic in style functions are now removed, in favor of pure composition of smaller style functions.  Elliot has yet again resolved and managed complexity!

### 409 Conflict

Although Elliot realized a discipline of applying composition will serve as a main way to combat the Complexity Beast, he started noticing that the Complexity Beast always seems to be lurking *everytime* changes are made to the system.

Conflicted by his seemingly endless quest at managing complexity, he curiously asks his Design team an innocent question:

> **Elliot**: "Do we have a full understanding of what we are building?"
>
> **Design**: "Of course!"
>
> **Elliot**: "Where can I see a summary of the system of components we have built in the past few weeks?""
>
> **Design**: "They are in the mocks, docs, and these links."
>
> **Elliot**: "Is there a central place to see everything and how everything relates to each other?"
>
> **Design**: "No I don't think so, but that would be great to have.  We really need it too."

With the design resources sent to him, Elliot meticulously organizes the notes by date/domain/owner/etc.  The notes are obviously imperfect, and no amount of organization is able to fully describe the system he thought he had built over the weeks.

Over in another room, he overhears teammates arguing over the conflict on what the correct color of <code><span style="color: #ff85c0;">BigNotRedButton</span></code> should be.

### Goodbye Elliot

Elliot realizes that the source of complexity was never truly related to his implementation, nor by the decisions made the Design team.  At every point, everyone was doing their best and due dilligence in building a system that made sense.  He eventually came to a realization that the Complexity Beast will always be lurking somewhere, waiting for the right moment to strike on people's eventual bad decisions implementation.

Understanding and coming to peace that the source of complexity is related to an imperfect knowledge of systems, Elliot finds renewed strength and begins thinking about how one might increase the transparency and accessibility of system knowledge.

The Design team did mention that *"We really need it too"*, he thought to himself.

### What went wrong?

In hindsight, it is easy to identify the mistakes that Elliot made technically (i.e. not favoring composition in earlier stages), but that would be disrespectful on our end to forget how well-intentioned Elliot had tried in writing just the minimal code that accurately satisfies requirements.  In fact, as we followed his journey, every choice he made was *thoughtful and reasonable* in relation to the scope of the problem presented to him.  Pre-optimizing and early abstractions can be argued to lead to more complexity since they don't solve the current problem meaningfully.

It is also tempting to assign blame to the Design team on not maintaining a source of truth.  Every team works with tools and sources of truth.  As engineers, we abstract and share code to create sources of truth, but we face the exact problems at every level that the Design team does, which is imperfect knowledge of the system we are building.  Unless it is a deliberate effort on our part to *systematically* build [system knowledge][system-knowledge], our decisions will always be made on imperfect knowledge.

It is this very imperfect knowledge, that is the real essence of how complexity arises.  Without sufficient knowledge of the system, we make short-sighted decisions that affect the introduce unintended complexity of the system.  Any abstractions built on these decisions will further propagate the complexity and misknowledge of the system for future contributors.

## System Knowledge

In the previous example, we observed how imperfect knowledge of systems creates inevitable complexity.  While building abstractions is important in reducing a system's complexity, it is important to note that:

> Wrong abstractions can create more complexity than duplication.

The next sections cover how [the Unix Philosophy](#the-unix-philosophy), and correspondingly [the `uinix` philosophy](#the-uinix-philosophy), aid in improving system knowledge.

### The Unix philosophy

With Elliot's journey, we [learned](#a-few-weeks-later) that while we cannot avoid and conquer complexity, our most powerful tool is a careful and meaningful breakdown of programs into smaller composable parts.  What Elliot has done was managing complexity using the Unix philosophy.

The [Unix philosophy][unix-philosophy] proposes minimalist and modular software development.  Unix programs tend to:
- do one thing and do it well
- be inteoperable with other relating programs
- are modular, composable, and extensible.

In relation to [system knowledge](#system-knowledge), by nature of their simplicity and interoperability, it is easy to study and understand higher forms of programs that are built with Unix programs.

### The `uinix` philosophy

The `uinix` philosophy is based on [the Unix philosophy](#the-unix-philosophy), and approaches all aspects of UI development by keeping programs small and interoperable.

Like Unix programs, `uinix` programs aim to:
- do one thing and do it well
- be interoperable with other relating programs
- are modular, composable, and extensible.

In relation to [system knowledge](#system-knowledge), the API surfaces of `uinix` programs are kept extremely small.

A detailed look at the `uinix` ecosytem of [packages][packages] will provide a brief overview on how the ecosystem approaches UI development with *small* opinionated sets of modular programs and patterns.

### `uinix` system specs

System specs and configurations in `uinix` are designed to serve as sources of truth, allowing access to system knowledge even in the absence of tooling.  The [`uinix-ui`][uinix-ui] UI system library is designed in this exact way, and makes the UI system specs of `theme`, `icons`, `styles`, `typography` easily accessible even in its native serializable form.

Shown below are the actual `uinix-ui` system specs used to render this site and whitepaper:

#### `theme`
<pre>
  <code className="language-json">
    {JSON.stringify(theme, null, 2)}
  </code>
</pre>

#### `icons`
<pre>
  <code className="language-json">
    {JSON.stringify(icons, null, 2)}
  </code>
</pre>

#### `styles`
<pre>
  <code className="language-json">
    {JSON.stringify(styles, null, 2)}
  </code>
</pre>

#### `typography`
<pre>
  <code className="language-json">
    {JSON.stringify(typography, null, 2)}
  </code>
</pre>

These specs can also be rendered in more interactive ways that further improves understanding of system knowledge through visual means, as shown in the following custom theme previewer.

<img src={themePreviewImage} width="100%" />

`uinix` specs, as shown above, are interoperable with each other, and together with a base set of just four primitive but interoperable and composable components (`Element`, `Icon`, `Layout`, `Text`), the `uinix` philosophy allows building and composing complex UIs with ease, as detailed in the upcoming section.

### `uinix` systems

Visit https://systems.uinix.dev for a demo of UI systems built with [`uinix-ui`][uinix-ui].

The demos showcase popular web applications that are reverse-engineered into a *minimal* set of specs (`theme`, `icons`, `typography`, and `styles`), and built using just four component primitives (`Element`, `Layout`, `Icon`, and `Text`).

More importantly, the [system knowledge](#system-knowledge) of every UI system is easily and explicitly accessible.

## Conclusions

As we finally come to the closing section of this document, we want to take some time to reflect on key points raised during our journey on managing complexity in UI systems.

- It remains important to always think of [UI as a function of state](#ui--fs) (i.e. ui = f(s)).
- Treatment of styles and CSS should be no different than treatment of regular functions.  We have learned a few techniques for approaching this by simply emphasizing and thinking of [styles as a function of state](#style--fs) (i.e. style = f(s)).
- [Design systems](#design-systems) and [UI systems](#ui-systems), while highly important in managing complexity of projects, should be thought of no more as simply closed systems.
- We learned basic concepts and unavoidable truths about the [entropy](#entropy) and [complexity](#complexity) of closed systems.
- We followed the journey of [Elliot and the Complexity Beast](#elliot-and-the-complexity-beast) to gain a deeper understanding, through the use of a simple example, that complexity is unavoidable despite the well-intentioned choices we make.
- We identified that such problems relate to imperfect [system knowledge](#system-knowledge) and seek remediations through [the Unix philosophy](#the-unix-philosophy).
- We provided a remediation that is more specific to UI systems, by introducing how [the `uinix` philosophy](#the-uinix-philosophy) and its focus on building interoperable primitives that emphasize on expanding and making [system knowledge](#system-knowledge) more accessible.

With final closing remarks, I hope that our journey with [UI systems and Complexity](#ui-systems-and-complexity) has made it clear on the truths that complexity can never be avoided.  As much as this fact may sound troubling, we now have a deeper understanding of the problem that was oftenly overlooked.  With a peace of what we cannot change, and an understanding of what we can change and improve, we gain a newfound respect for the systems we build, and own both our choices and complexity proudly.  Because, that is exactly the *story of software engineering* after all:

> A journey of understanding and building systems.

## Influences

This document and [the `uinix` philosophy](#the-uinix-philosophy) is largely inspired by the following projects and their relating focuses:

- [`fela`][fela]: style as a function of state
- [`react`][react]: view as a function of state
- [`redux`][redux]: state management via composition
- [`theme-ui`][theme-ui]: the first [UI system library](#ui-system-libraries) to formally define interoperable system components with a theme spec

## References

This document references concepts and ideas from the following sources:

- Complexity
  - [Out of the Tarpit][out-of-the-tarpit]
- UI System Libraries
  - [`theme-ui`][theme-ui]
  - [`rebass`][rebass] (progenitor of `theme-ui`)
- ui = f(s)
  - [`fela`][fela]
  - [`react`][react]
  - [`redux`][redux]
- CSS in JS
  - [`emotion`][emotion]
  - [`styled-components`][styled-components]

## License

Copyright Â© 2021 Chris Zhou. This document is licensed under a [Creative Commons Attribution 4.0 International License]((https://creativecommons.org/licenses/by/4.0/)).

<!-- defs -->
[antd]: https://github.com/ant-design/ant-design/
[ant-design-system]: https://ant.design/
[carbon-components]: https://github.com/carbon-design-system/carbon/tree/main/packages/components
[carbon-design-system]: https://www.carbondesignsystem.com/
[complexity]: https://en.wikipedia.org/wiki/Complexity
[design-system]: https://en.wikipedia.org/wiki/Design_system
[element-component]: ../api/components/element
[emotion]: https://github.com/emotion-js/emotion
[fela]: https://github.com/robinweser/fela
[material-design-system]: https://material.io/
[material-ui]: https://github.com/mui-org/material-ui
[out-of-the-tarpit]: http://curtclifton.net/papers/MoseleyMarks06a.pdf
[packages]: ../packages
[rebass]: https://github.com/rebassjs/rebass
[react]: https://github.com/facebook/react
[redux]: https://github.com/reduxjs/redux
[second-law-of-thermodynamics]: https://en.wikipedia.org/wiki/Second_law_of_thermodynamics
[software-entropy]: https://en.wikipedia.org/wiki/Software_entropy
[styled-components]: https://github.com/styled-components/styled-components
[theme-ui]: https://github.com/system-ui/theme-ui
[unix-philosophy]: https://en.wikipedia.org/wiki/Unix_philosophy
[uinix-ui]: https://github.com/uinix-js/uinix-ui
